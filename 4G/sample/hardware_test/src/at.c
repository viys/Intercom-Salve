/******************************************************************************* ** File Name:   plat_test.c ** Copyright:   Copyright 2020-2020 by Xiamen CHEERZING IOT Technology Co., Ltd. **              All Rights Reserved. **              This software is supplied under the terms of a license **              agreement or non-disclosure agreement with Cheerzing. **              Passing on and copying of this document,and communication **              of its contents is not permitted without prior written **              authorization. ** Description: plat api test code *******************************************************************************  ******************************************************************************* **                        Edit History                                        * ** ---------------------------------------------------------------------------* ** DATE           NAME             Description: **----------------------------------------------------------------------------* ** 2020-04-26     suzhiliang         Create. ******************************************************************************//******************************************************************************* ** Header Files ******************************************************************************/ #include "app_main.h"#include "at.h"#include "device_init.h"#include "uart_init.h"/******************************************************************************* ** MACROS ******************************************************************************/#define AT_CMD_BUF_MAX_LEN     (2048-8)#define AT_CMD_RSP_MAX_LEN     200#define EX_AT_CMD_TAB_SIZE sizeof(s_externAtCmdTab)/sizeof(s_externAtCmdTab[0])/******************************************************************************* ** Type Definitions ******************************************************************************/typedef int(*EX_AT_PRO_CALLBACK)(char* data, uint32 dataLen);typedef struct{    char* cmdStr;    EX_AT_PRO_CALLBACK callBack;} EX_AT_PRO_TAB_T; /******************************************************************************* ** Variables ******************************************************************************/static char s_atCmdStr[AT_CMD_BUF_MAX_LEN+1] = {0};static int echoflag = 1;static int g_suspend = 0;/******************************************************************************* ** External Function Declerations ******************************************************************************/static EX_AT_PRO_TAB_T s_externAtCmdTab[] ={    {"+GPIOCFGSET",AtGpioCfgSet},    {"+GPIOCFGGET",AtGpioCfgGet},    {"+GPIOSET",AtGpioSet},    {"+GPIOGET",AtGpioGet},	{"+DISPLAY",AtDisplay},	{"+ADCVALUE",AtAdcValue},	{"+RECORD",AtRecord},	{"+AUDIOPLAY",AtAudioPlay},	{"+AUDIOVOLUME",AtAudioVolume},	{"+AUDIOCHANNELSET",AudioChannelSet},	{"+AUDIOCHANNELGET",AudioChannelGet},	{"+LCDBACK",AtLcdBack},	{"+BACKCMD",AtBackCmd},	{"+KEYPADCMD",AtKeypadCmd},	{"+CHARGECFG",AtChargeCfg},	{"+CHARGECMD",AtChargeCmd},	{"+APPVERSIONS",AtAppVersions},	{"+UARTCFG",AtUartCfg},	{"+SINK",AtSink},	{"+ECHOCMD",AtEchoCmd},	{"+IMEI",AtImeiGet},	{"+IIC",AtIic},    {"+SPIFLASH",AtSpiFlash},        {"+SPIFS",AtSpiFs},    {"+SPI",AtSpi},    {"+SD",AtSd},    {"+SUSPEND", AtSuspend},    {"+CMDLIST",AtCmdList},};/******************************************************************************* ** Local Function Declerations ******************************************************************************//******************************************************************************* ** Functions ******************************************************************************/int AtEchoCmd(char* data, uint32 dataLen){    //判断是否有参数    if((0 == dataLen) || ('=' != *data))    {        return FAIL;    }    data++;    dataLen--;    if (*data == '?')    {        ATPrintf("+ECHOCMD: (0-1)\r\n");        return SUCCESS;    }        //判断参数    if(('0' != *data) && ('1' != *data))    {        LogPrintf("0/1 param error\r\n");        return FAIL;    }    echoflag = atoi(data);    return SUCCESS;}/** *    小写转大写 *     *    @param[in out]  str   in待转字符串 out转换大写后字符串   *    @return 0 SUCCESS  -1 FAIL *//*static int StrLowToUp(char *str){    uint32 len = 0;    uint32 i = 0;    if(NULL == str)    {        return -1;    }    len = strlen(str);    for(i=0; i<len; i++)    {        if((str[i] >= 'a') && (str[i] <= 'z'))        {            str[i] = str[i]-32;        }    }    return 0;}*//** *    AT数据读取 *     *    @return 0 SUCCESS  -1 FAIL */static int At_CmdDataGet(void){    uint32 availableLen = 0;    uint32 readLen = 0;    int ret = SUCCESS;        //获取缓存区数据字节长    ret = KING_UartGetAvailableBytes(UART_1,&availableLen);    if((0 == availableLen) || (FAIL == ret))    {        LogPrintf("KING_UartGetAvailableBytes() Failed! errcode=0x%x\r\n", KING_GetLastErrCode());        return FAIL;    }    if (availableLen > AT_CMD_BUF_MAX_LEN)    {        availableLen = AT_CMD_BUF_MAX_LEN;    }    KING_SysLog("uart available len: %d \r\n",availableLen);    //读缓存内容    memset(s_atCmdStr, 0x00, AT_CMD_BUF_MAX_LEN+1);    ret = KING_UartRead(UART_1, (uint8 *)s_atCmdStr, availableLen,&readLen);    if (FAIL == ret)    {        LogPrintf("KING_UartRead() Failed! errcode=0x%x\r\n", KING_GetLastErrCode());        return FAIL;    }    KING_UartPurge(UART_1);    KING_SysLog("uart read len: %d read data: %s \r\n",readLen ,s_atCmdStr);    //转换成大写    //StrLowToUp(s_atCmdStr);    return SUCCESS;}/** *    AT命令处理判断 *     * */void At_CmdHandle(void){    uint32 len;    int ret = -1;    int i = 0;    char *p_cmd;    ret = At_CmdDataGet();    if (FAIL == ret)    {        LogPrintf("at read error\r\n");        return;    }        if(1 == echoflag)    {        //回显        ATPrintf("%s\r\n",s_atCmdStr);    }    //判断是不是AT指令    if (strncasecmp(s_atCmdStr, "AT", 2))    {        ATPrintf("ERROR\r\n");        return;    }    //处理\r\n问题    p_cmd = strstr(s_atCmdStr, "\r\n");    if (NULL != p_cmd)    {        memset(p_cmd,0x00,2);    }        //如果只是AT    if (!strncasecmp(s_atCmdStr, "AT", strlen(s_atCmdStr)))    {        ATPrintf("OK\r\n");        return;    }    //查找AT指令    for ( i = 0; i < EX_AT_CMD_TAB_SIZE; i++)    {        len = strlen((s_externAtCmdTab[i].cmdStr));        if (strncasecmp(s_atCmdStr+2, s_externAtCmdTab[i].cmdStr, len) == 0)        {            if (s_externAtCmdTab[i].callBack != NULL)            {                 ret = s_externAtCmdTab[i].callBack(s_atCmdStr+2+len, strlen(s_atCmdStr)-2-len);                if (FAIL == ret)                {                    ATPrintf("ERROR\r\n");                }                else                {                    ATPrintf("OK\r\n");                }                return;              }        }    }    //未找到    ATPrintf("ERROR\r\n");    return;}int AtSuspend(char* data, uint32 dataLen){    int value;         if ((0 == dataLen) || ('=' != *data))    {        return FAIL;    }    data++;    if (*data == '?')    {        ATPrintf("+SUSPEND: (0-1)\r\n");        return SUCCESS;    }    value = atoi(data);    value = !!value;    if (g_suspend != value)    {        if (0 == value)        {            KING_WakeLock(LOCK_SUSPEND,(uint8 *)"mainlock");        }        else        {            KING_WakeUnlock(LOCK_SUSPEND,(uint8 *)"mainlock");        }        g_suspend = value;    }    return SUCCESS;}int AtCmdList(char* data, uint32 dataLen){    uint32 i;    if ((0 != dataLen) && (data[0] == '=') && (data[1] == '?'))    {        return SUCCESS;    }        if(0 != dataLen)    {        return FAIL;    }    ATPrintf("+CMDLIST: \r\n");    for (i = 0; i < EX_AT_CMD_TAB_SIZE; i++)    {        if (strcmp(s_externAtCmdTab[i].cmdStr,"+CMDLIST"))        {            ATPrintf("AT%s\r\n",s_externAtCmdTab[i].cmdStr);        }    }    return SUCCESS;}